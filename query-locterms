#!/usr/bin/env python3
'''
query-locterms: interactively print information about an LCSH term.

Basic usage:
    query-locterms -d IDENTIFIER [IDENTIFIER ...]
or
    query-locterms -t IDENTIFIER [IDENTIFIER ...]

The LoCTerms database process must already be running.  The action to be
performed must be indicated by using one of the following two command
line flags:

  -d    Describe the LCSH term(s) given on the command line
  -t    Trace the path from the given LCSH term(s) to root terms

By default, this uses the operating system's keyring/keychain functionality
to get the user name and password needed to access the LoCTerms database over
the network.  If no such credentials are found, it will query the user
interactively for the user name and password, and then store them in the
keyring/keychain unless the -X argument is given so that it does not have to
ask again in the future.  It is also possible to supply a user name and
password directly using the -u and -p options, respectively, but this is
discouraged because it is insecure on multiuser computer systems. (Other
users could run "ps" in the background and see your credentials).

Additional arguments can be used to specify the host (-H) and port (-P) on
which the database process is listening.  The default for the host is
"localhost" and the default port is whatever is configured in your instance
of MongoDB.

Finally, the remaining arguments on the command line are assumed to be
identifiers of terms in the Library of Congress Subject Headings (LCSH).
'''

__version__ = '1.0.0'
__author__  = 'Michael Hucka <mhucka@caltech.edu>'
__email__   = 'mhucka@caltech.edu'
__license__ = 'GPLv3'

import getpass
import keyring
import sys
import operator
import os
import plac
import pprint
from   pymongo import MongoClient
import socket
try:
    from termcolor import colored
except:
    pass


# Global constants.
# .............................................................................

_CONN_TIMEOUT = 5000
'''Time to wait for connection to database, in milliseconds.'''

_DEFAULT_PORT = 27017
'''Default network port for MongoDB if no explicit port number is given.'''

_DB_NAME = 'lcsh-db'
'''The name of our LoCTerms database in MongoDB.'''

_KEYRING_PATH = "org.casics.locterms"
'''The name of the keyring entry for LoCTerms client users.'''


# Main body.
# .............................................................................

def main(describe=False, trace=False, user=None, password=None,
         host=None, port=None, nocolor=False, nokeyring=False, *terms):
    '''Query LoCTerms for information about an LCSH term.  The LoCTerms
database process must already be running.  The action to be performed must
be indicated by using one of the following two command line flags:

  -d    Describe the LCSH term(s) given on the command line
  -t    Trace the path from the given LCSH term(s) to root terms

By default, this uses the operating system's keyring/keychain functionality
to get the user name and password needed to access the LoCTerms database over
the network.  If no such credentials are found, it will query the user
interactively for the user name and password, and then store them in the
keyring/keychain unless the -X argument is given so that it does not have to
ask again in the future.  It is also possible to supply a user name and
password directly using the -u and -p options, respectively, but this is
discouraged because it is insecure on multiuser computer systems. (Other
users could run "ps" in the background and see your credentials).

Additional arguments can be used to specify the host (-H) and port (-P) on
which the database process is listening.  The default for the host is
"localhost" and the default port is whatever is configured in your instance
of MongoDB.

Finally, the remaining arguments on the command line are assumed to be
identifiers of terms in the Library of Congress Subject Headings (LCSH).
'''
    # Our default is to color output for easier reading, which means the
    # command line flag makes more sense as a negated value (i.e., "nocolor").
    # Dealing with a negated variable is confusing, so turn it around here.
    colorize = 'termcolor' in sys.modules and not nocolor

    # Check arguments.
    if not trace and not describe:
        raise SystemExit(colorcode('No action specified. Use -h for help.', 'error'))
    if trace and describe:
        raise SystemExit(colorcode('Can only perform one action at a time.', 'error'))
    if not user or not password:
        # If no user or password given, check keyring.
        #    If nothing found there, prompt the user.
        # If only user given, check keyring for password for that user
        #    If not found there, prompt the user.
        if not nokeyring:
            (user, password) = get_keyring_credentials()
        if not user:
            # Couldn't find it.  Ask the user.
            msg('No user credentials found or given.', 'warning')
            (user, password) = ask_for_credentials()
        if not user or not password:
            # We tried but failed to get user credentials.
            raise SystemExit(colorcode('Must provide a database user login and password.', 'error'))
        if not nokeyring:
            # Save the credentials.
            (u, p) = get_keyring_credentials()
            if (not u and not p) or (u != user or p != password):
                save_keyring_credentials(user, password)
    if not terms:
        raise SystemExit(colorcode('No LCSH terms given. Use -h for help.', 'error'))
    if not host:
        host = "localhost"
    if not port:
        port = _DEFAULT_PORT

    # Do some simple sanity checks:
    for t in terms:
        if not t.startswith('sh'):
            msg('Identifiers must be LCSH identifiers, like sh89003287',
                'error', colorize)
            return
    if not port_occupied(host, int(port)):
        msg('Cannot connect to port {} -- is the database running?'.format(port),
            'error', colorize)
        return

    # Connect to the LCSH database.
    url = ('mongodb://' + user + ':' + password + '@' + host + ':' + str(port)
           + '/' + _DB_NAME + '?authSource=admin')
    db = MongoClient(url, tz_aware=True, serverSelectionTimeoutMS=_CONN_TIMEOUT)
    lcsh = db[_DB_NAME].terms

    # Watch out for the fact that with MongoDB, we may be able to connect yet
    # still be unable to actually do anything.  The next step acts as a test.
    try:
        count = lcsh.count()
    except Exception as e:
        raise SystemExit(colorcode('Failed to access database: {}'.format(e), 'error'))

    # Do the work.
    try:
        msg('='*70, 'dark', colorize)
        if trace:
            for t in terms:
                trace_term(lcsh, t, colorize)
        if describe:
            for t in terms:
                explain_term(lcsh, t, colorize)
                msg('')
        msg('='*70, 'dark', colorize)
    except Exception as e:
        msg(colorcode(e, 'error'))


def trace_term(lcsh, term, colorize):
    '''Trace a term's "broader" links until we can't go any further.'''
    entry = lcsh.find_one({'_id': term})
    if not entry:
        msg('Could not find {} in the database'.format(term), 'error', colorize)
        return
    print_paths(get_paths(lcsh, entry), colorize)


def explain_term(lcsh, term, colorize):
    '''Print a description of one term.'''
    entry = lcsh.find_one({'_id': term})
    if not entry:
        msg('Could not find {} in the database'.format(term), 'error', colorize)
        return
    print_details(entry, colorize)


def get_paths(lcsh, entry):
    '''Recursively follow "broader" term links, and return a list of results.'''
    paths = []
    if not entry['broader']:
        paths = [[entry]]
    else:
        for broader in entry['broader']:
            parent = lcsh.find_one({'_id': broader})
            if not parent:
                raise SystemExit(colorcode('Broader term {} not found.'.format(broader),
                                           'error', colorize))
            if parent['broader']:
                for path in get_paths(lcsh, parent):
                    paths.append([entry] + path)
            else:
                paths.append([entry] + [parent])
    return paths


def print_paths(paths, colorize):
    '''Print a summary of the terms in the given list of paths.'''
    # Paths assumed to be a list of lists of the form:
    # [ [leaf_term, parent_term, parent_parent_term, ...],
    #   [leaf_term, parent_term, parent_parent_term, ...],
    #   ...
    # ]
    for p in paths:
        from_top = list(reversed(p))
        print_one(from_top[0], indent='', colorize=colorize)
        indent = '└─ '
        for index, term in enumerate(from_top[1:]):
            print_one(term, indent, colorize)
            indent = '   ' + indent
        msg('')


def print_one(term, indent='', colorize=False):
    '''Print one term, as an identifier plus its label.'''
    label = term['label'] if term['label'] else '(no label)'
    msg('{}{}: {}'.format(indent, colorcode(term['_id'], 'bold', colorize), label))


def print_details(entry, colorize=False):
    '''Print details about a single term.'''
    label = entry['label'] if entry['label'] else '(no label)'
    msg(colorcode(entry['_id'], 'bold', colorize) + ':')
    msg(colorcode('         URL: ', 'dark', colorize) +
        'http://id.loc.gov/authorities/subjects/' + entry['_id'] + '.html')
    msg(colorcode('       label: ', 'dark', colorize) + label)
    if entry['alt_labels']:
        msg(colorcode('  alt labels: ', 'dark', colorize)
            + '\n              '.join(entry['alt_labels']))
    else:
        msg('  alt labels: (none)', 'dark', colorize)
    if entry['narrower']:
        msg(colorcode('    narrower: ', 'dark', colorize) + ', '.join(entry['narrower']))
    else:
        msg('    narrower: (none)', 'dark', colorize)
    if entry['broader']:
        msg(colorcode('     broader: ', 'dark', colorize) + ', '.join(entry['broader']))
    else:
        msg('     broader: (none)', 'dark', colorize)
    if entry['topmost']:
        msg(colorcode('     topmost: ', 'dark', colorize) + ', '.join(entry['topmost']))
    else:
        msg('     topmost: (none)', 'dark', colorize)
    if entry['note']:
        prefix = colorcode('        note: ', 'dark', colorize)
        indent = len(prefix)
        text = pprint.pformat(entry['note'], width=77-indent)
        text = text[1:-1]
        msg(prefix + text)
    else:
        msg('        note: (none)', 'dark', colorize)


# Utilities for printing messages.
# .............................................................................

def msg(text, flags=None, colorize=True):
    if colorize:
        print(colorcode(text, flags), flush=True)
    else:
        print(text, flush=True)


def colorcode(text, flags=None, colorize=True):
    (prefix, color, attributes) = color_codes(flags)
    if colorize:
        if attributes and color:
            return colored(text, color, attrs=attributes)
        elif color:
            return colored(text, color)
        elif attributes:
            return colored(text, attrs=attributes)
        else:
            return text
    elif prefix:
        return prefix + ': ' + text
    else:
        return text


def color_codes(flags):
    color  = ''
    prefix = ''
    attrib = []
    if type(flags) is not list:
        flags = [flags]
    if 'error' in flags:
        prefix = 'ERROR'
        color = 'red'
    if 'warning' in flags:
        prefix = 'WARNING'
        color = 'yellow'
    if 'info' in flags:
        color = 'green'
    if 'white' in flags:
        color = 'white'
    if 'blue' in flags:
        color = 'blue'
    if 'grey' in flags:
        color = 'grey'
    if 'cyan' in flags:
        color = 'cyan'
    if 'underline' in flags:
        attrib.append('underline')
    if 'bold' in flags:
        attrib.append('bold')
    if 'reverse' in flags:
        attrib.append('reverse')
    if 'dark' in flags:
        attrib.append('dark')
    return (prefix, color, attrib)


# Credentials/keyring functions
# .............................................................................
# Explanation about the weird way this is done: the Python keyring module
# only offers a single function for setting a password associated with an
# identifier.  However, we need to store both a user name and an identifier
# and retrieve the user name when we don't know it yet.  So, the approach
# here is to subvert the set_password() functionality to store the user name
# under the fake user "username" and the password under the fake user
# "password".

def get_keyring_credentials(user=None):
    '''Look up user credentials for user 'user'.  If 'user' is None, gets
    the user name stored in the "username" field.'''
    if not user:
        user = keyring.get_password(_KEYRING_PATH, "username")
    password = keyring.get_password(_KEYRING_PATH, "password")
    return (user, password)


def save_keyring_credentials(user, password):
    '''Save the user and password info to the keyring.'''
    keyring.set_password(_KEYRING_PATH, "username", user)
    keyring.set_password(_KEYRING_PATH, "password", password)
    msg('Credentials for user "{}" saved to keyring'.format(user), 'info')


def ask_for_credentials(user=None):
    '''Ask the user for the password, and optionally also the user name.'''
    if not user:
        user = input("User name: ")
    password = getpass.getpass()
    return (user, password)


# Miscellaneous utilities.
# .............................................................................

def port_occupied(host, port):
    '''Returns True if the given port occupied, false if not.'''
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.bind((host, port))
    except socket.error as e:
        # This has value 48 on macOS but apparently 98 on others.
        return (e.errno in [48, 98])
    finally:
        sock.close()


# Plac annotations for main function arguments
# .............................................................................
# Argument annotations are: (help, kind, abbrev, type, choices, metavar)
# Plac automatically adds a -h argument for help, so no need to do it here.

main.__annotations__ = dict(
    describe  = ('print details about given LCSH term(s)',    'flag',   'd'),
    host      = ('database server host',                      'option', 'H'),
    password  = ('database user password',                    'option', 'p'),
    port      = ('database connection port number',           'option', 'P'),
    user      = ('database user name',                        'option', 'u'),
    trace     = ('trace paths from given id to root term(s)', 'flag',   't'),
    nocolor   = ('do not color-code the output',              'flag',   'x'),
    nokeyring = ('do not use a keyring',                      'flag',   'X'),
    terms     = 'one or more LCSH identifiers, like sh85118553',
)


# Entry point
# .............................................................................

plac.call(main)


# For Emacs users
# ......................................................................
# Local Variables:
# mode: python
# python-indent-offset: 4
# End:
