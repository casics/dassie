#!/usr/bin/env python3
'''
query-locterms: interactively print information about an LCSH term.

Usage:
    query-locterms -u USER -p PASSWORD -d IDENTIFIER [IDENTIFIER ...]
or
    query-locterms -u USER -p PASSWORD -t IDENTIFIER [IDENTIFIER ...]

Additional arguments can be used to specify the host (-H) and port (-P) on
which the database process is listening.  The default for the host is
"localhost" and the default port is whatever is configured in your instance
of MongoDB.

You can optionally provide the user name and password as arguments -u and -p
(respectively), but note that this is insecure on multiuser computer systems
where other users could run "ps" in the background and see your credentials.

The following actions are understood; note that only one can be indicated
at a time, but one or the other must be provided:

  -d    Describe the term(s) given on the command line
  -t    Trace the path from the given term(s) to root terms

The remaining arguments on the command line are assumed to be identifiers of
terms in the Library of Congress Subject Headings (LCSH).

'''

__version__ = '1.0.0'
__author__  = 'Michael Hucka <mhucka@caltech.edu>'
__email__   = 'mhucka@caltech.edu'
__license__ = 'GPLv3'

import getpass
import sys
import operator
import os
import plac
import pprint
from   pymongo import MongoClient
import socket
try:
    from termcolor import colored
except:
    pass


# Global constants.
# .............................................................................

_CONN_TIMEOUT = 5000
'''Time to wait for connection to database, in milliseconds.'''

_DEFAULT_PORT = 27017
'''Default network port for MongoDB if no explicit port number is given.'''

_DB_NAME = 'lcsh-db'
'''The name of our LoCTerms database in MongoDB.'''


# Main body.
# .............................................................................

def main(describe=False, trace=False, user=None, password=None,
         host="localhost", port=None, nocolor=False, *terms):
    '''Query LoCTerms for information about an LCSH term.  The LoCTerms
database process must already be running.  This program will prompt for the
user name and password to use to connect to the database.  Additional
arguments can be used to specify the host (-H) and port (-P) on which the
database process is listening.  The default for the host is "localhost" and
the default port is whatever is configured in your instance of MongoDB.

You can optionally provide the user name and password as arguments -u and -p
(respectively), but note that this is insecure on multiuser computer systems
where other users could run "ps" in the background and see your credentials.

This program also requires an argument to dictate the action to perform.
The following actions are understood; note that only one can be indicated
at a time, but one or the other must be given:

  -d    Describe the term(s) given on the command line
  -t    Trace the path from the given term(s) to root terms

Finally, the remaining arguments on the command line are assumed to be
identifiers of terms in the Library of Congress Subject Headings (LCSH).

    '''
    # Our default is to color output for easier reading, which means the
    # command line flag makes more sense as a negated value (i.e., "nocolor").
    # Dealing with a negated variable is confusing, so turn it around here.
    colorize = 'termcolor' in sys.modules and not nocolor

    # Check arguments.
    if not trace and not describe:
        raise SystemExit(colorcode('No action specified. Use -h for help.', 'error'))
    if trace and describe:
        raise SystemExit(colorcode('Can only perform one action at a time.', 'error'))
    if not user or not password:
        user = input("User name: ")
        password = getpass.getpass()
        if not user or not password:
            raise SystemExit(colorcode('Must provide a database user login and password.', 'error'))
    if not terms:
        raise SystemExit(colorcode('No LCSH terms given. Use -h for help.', 'error'))
    if not port:
        port = _DEFAULT_PORT

    # Do some simple sanity checks:
    for t in terms:
        if not t.startswith('sh'):
            msg('Identifiers must be LCSH identifiers, like sh89003287',
                'error', colorize)
            return
    if not port_occupied(host, int(port)):
        msg('Cannot connect to port {} -- is the database running?'.format(port),
            'error', colorize)
        return

    # Connect to the LCSH database.
    url = ('mongodb://' + user + ':' + password + '@' + host + ':' + str(port)
           + '/' + _DB_NAME + '?authSource=admin')
    db = MongoClient(url, tz_aware=True, serverSelectionTimeoutMS=_CONN_TIMEOUT)
    lcsh = db[_DB_NAME].terms

    # Do the work.
    msg('='*70, 'dark', colorize)
    if trace:
        for t in terms:
            trace_term(lcsh, t, colorize)
    if describe:
        for t in terms:
            explain_term(lcsh, t, colorize)
            msg('')
    msg('='*70, 'dark', colorize)


def trace_term(lcsh, term, colorize):
    '''Trace a term's "broader" links until we can't go any further.'''
    entry = lcsh.find_one({'_id': term})
    if not entry:
        msg('Could not find {} in the database'.format(term), 'error', colorize)
        return
    print_paths(get_paths(lcsh, entry), colorize)


def explain_term(lcsh, term, colorize):
    '''Print a description of one term.'''
    entry = lcsh.find_one({'_id': term})
    if not entry:
        msg('Could not find {} in the database'.format(term), 'error', colorize)
        return
    print_details(entry, colorize)


def get_paths(lcsh, entry):
    '''Recursively follow "broader" term links, and return a list of results.'''
    paths = []
    if not entry['broader']:
        paths = [[entry]]
    else:
        for broader in entry['broader']:
            parent = lcsh.find_one({'_id': broader})
            if not parent:
                raise SystemExit(colorcode('Broader term {} not found.'.format(broader),
                                           'error', colorize))
            if parent['broader']:
                for path in get_paths(lcsh, parent):
                    paths.append([entry] + path)
            else:
                paths.append([entry] + [parent])
    return paths


def print_paths(paths, colorize):
    '''Print a summary of the terms in the given list of paths.'''
    # Paths assumed to be a list of lists of the form:
    # [ [leaf_term, parent_term, parent_parent_term, ...],
    #   [leaf_term, parent_term, parent_parent_term, ...],
    #   ...
    # ]
    for p in paths:
        from_top = list(reversed(p))
        print_one(from_top[0], indent='', colorize=colorize)
        indent = '└─ '
        for index, term in enumerate(from_top[1:]):
            print_one(term, indent, colorize)
            indent = '   ' + indent
        msg('')


def print_one(term, indent='', colorize=False):
    '''Print one term, as an identifier plus its label.'''
    label = term['label'] if term['label'] else '(no label)'
    msg('{}{}: {}'.format(indent, colorcode(term['_id'], 'bold', colorize), label))


def print_details(entry, colorize=False):
    '''Print details about a single term.'''
    label = entry['label'] if entry['label'] else '(no label)'
    msg(colorcode(entry['_id'], 'bold', colorize) + ':')
    msg(colorcode('         URL: ', 'dark', colorize) +
        'http://id.loc.gov/authorities/subjects/' + entry['_id'] + '.html')
    msg(colorcode('       label: ', 'dark', colorize) + label)
    if entry['alt_labels']:
        msg(colorcode('  alt labels: ', 'dark', colorize)
            + '\n              '.join(entry['alt_labels']))
    else:
        msg('  alt labels: (none)', 'dark', colorize)
    if entry['narrower']:
        msg(colorcode('    narrower: ', 'dark', colorize) + ', '.join(entry['narrower']))
    else:
        msg('    narrower: (none)', 'dark', colorize)
    if entry['broader']:
        msg(colorcode('     broader: ', 'dark', colorize) + ', '.join(entry['broader']))
    else:
        msg('     broader: (none)', 'dark', colorize)
    if entry['topmost']:
        msg(colorcode('     topmost: ', 'dark', colorize) + ', '.join(entry['topmost']))
    else:
        msg('     topmost: (none)', 'dark', colorize)
    if entry['note']:
        prefix = colorcode('        note: ', 'dark', colorize)
        indent = len(prefix)
        text = pprint.pformat(entry['note'], width=77-indent)
        text = text[1:-1]
        msg(prefix + text)
    else:
        msg('        note: (none)', 'dark', colorize)


# Utilities for printing messages.
# .............................................................................

def msg(text, flags=None, colorize=True):
    if colorize:
        print(colorcode(text, flags), flush=True)
    else:
        print(text, flush=True)


def colorcode(text, flags=None, colorize=True):
    (prefix, color, attributes) = color_codes(flags)
    if colorize:
        if attributes and color:
            return colored(text, color, attrs=attributes)
        elif color:
            return colored(text, color)
        elif attributes:
            return colored(text, attrs=attributes)
        else:
            return text
    elif prefix:
        return prefix + ': ' + text
    else:
        return text


def color_codes(flags):
    color  = ''
    prefix = ''
    attrib = []
    if type(flags) is not list:
        flags = [flags]
    if 'error' in flags:
        prefix = 'ERROR'
        color = 'red'
    if 'warning' in flags:
        prefix = 'WARNING'
        color = 'yellow'
    if 'info' in flags:
        color = 'green'
    if 'white' in flags:
        color = 'white'
    if 'blue' in flags:
        color = 'blue'
    if 'grey' in flags:
        color = 'grey'
    if 'cyan' in flags:
        color = 'cyan'
    if 'underline' in flags:
        attrib.append('underline')
    if 'bold' in flags:
        attrib.append('bold')
    if 'reverse' in flags:
        attrib.append('reverse')
    if 'dark' in flags:
        attrib.append('dark')
    return (prefix, color, attrib)


# Miscellaneous utilities.
# .............................................................................

def port_occupied(host, port):
    '''Returns True if the given port occupied, false if not.'''
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.bind((host, port))
    except socket.error as e:
        # This has value 48 on macOS but apparently 98 on others.
        return (e.errno in [48, 98])
    finally:
        sock.close()


# Plac annotations for main function arguments
# .............................................................................
# Argument annotations are: (help, kind, abbrev, type, choices, metavar)
# Plac automatically adds a -h argument for help, so no need to do it here.

main.__annotations__ = dict(
    describe = ('print details about given LCSH term(s)',    'flag',   'd'),
    host     = ('database server host',                      'option', 'H'),
    password = ('database user password',                    'option', 'p'),
    port     = ('database connection port number',           'option', 'P'),
    user     = ('database user login',                       'option', 'u'),
    trace    = ('trace paths from given id to root term(s)', 'flag',   't'),
    nocolor  = ('do not color-code the output',              'flag',   'x'),
    terms    = 'one or more LCSH identifiers, like sh85118553',
)


# Entry point
# .............................................................................

plac.call(main)


# For Emacs users
# ......................................................................
# Local Variables:
# mode: python
# python-indent-offset: 4
# End:
